
interface MutList

struct MutCons : MutList {
    reg: Region^,
    var head: Int,
    tail: MutList^{reg}
}

struct Nil : MutList

package Lists {

    fn sublist(ls: MutList^, startIdx: Int) -> MutList^ {
        if startIdx < 0 {
            panic "negative index"
        } else if startIdx == 0 {
            return ls;
        } else if ls is MutCons {
            return sublist(ls.tail, startIdx - 1)
        } else if ls is Nil {
            panic "out of bounds"
        }
    }

    fn elemAt(ls: MutList^, idx: Int) -> Int {
        val subL = sublist(ls, idx);
        if subL is MutCons {
            return subL.head
        } else {
            panic "out of bounds"
        }
    }

    // returns the old value
    fn replaceAt(ls: MutList^, idx: Int, newVal: Int) -> Int {
        val subL = sublist(ls, idx);
        if subL is MutCons {
            val oldVal = subL.head;
            subL.head = newVal;
            return oldVal;
        } else {
            panic "out of bounds"
        }
    }

    fn mkList(reg: Region^, xs: arr Int) -> MutList^{reg} {
        var ls: MutList^{reg} = new Nil();
        for var i = #xs-1; i >= 0; i -= 1 {
            ls = new@reg MutCons(reg, xs[i], ls);
        };
        return ls;
    }

}
