
package Test {

    fn test(r: Region^) -> Region^ {
        var f: Foo^ = new@r Foo(10);    //> E : type Foo^ is forbidden in var position, as it captures the root capability
        val g: Foo^ = new@r Foo(10);    // OK
        val h: Region^;                 //> E : type Region^ is forbidden in uninitialized val position, as it captures the root capability
        h = newregion;

        // avoid warnings
        f.i + g.i;
        f = g;

        return h;
    }

}

mut struct Foo { i: Int }

mut struct Bar {
    var f: Foo^,    //> E : type Foo^ is forbidden in reassignable field position, as it captures the root capability
    g: Foo^         // OK
}
